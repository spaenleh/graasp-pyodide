const e="https://cdn.jsdelivr.net/pyodide/v0.21.0/full/";class n{static create(){return self.sessionStorage?new s:new t}}class t extends n{constructor(){super(),this.fs={}}getDir(){return Object.keys(this.fs)}getFile(e){return this.fs[e]}setFile(e,n){this.fs[e]=n}}class s extends n{getDir(){return Object.keys(self.sessionStorage)}getFile(e){return self.sessionStorage.getItem(e)}setFile(e,n){self.sessionStorage.setItem(e,n)}}class i{constructor(t){this.pyodide=null,this.postExec=t&&t.postExec||(()=>{}),this.write=t&&t.write||(e=>{}),this.clearText=t&&t.clearText||(()=>{}),this.setFigureURL=t&&t.setFigureURL||(e=>{}),this.notifyDirtyFile=t&&t.notifyDirtyFile||(e=>{}),this.notifyStatus=t&&t.notifyStatus||(e=>{}),this.handleInput=t&&t.handleInput||!1,this.inlineInput=t&&t.inlineInput||!1,this.pyodideURL=t&&t.pyodideURL||e;var s=/\/(v[\d.]+)\//.exec(this.pyodideURL);this.pyodideVersion=s?s[1]:"",this.requestInput=!1,this.inputPrompt=null,this.suspended=!1,this.dbgCurrentLine=null,this.preLoadedPackages=t?.preLoadedPackages,this.requestedModuleNames=[],this.loadedModuleNames=[],this.failedModuleNames=[],this.fs=n.create(),this.dirtyFiles=[]}load(e){this.notifyStatus("loading Pyodide "+this.pyodideVersion),globalThis.loadPyodide({indexURL:this.pyodideURL}).then((n=>{this.pyodide=n,this.pyodideVersion=n.version,this.notifyStatus("setup"),self.pyodideGlobal={requestModule:e=>this.requestModule(e),fs:this.fs,markFileDirty:e=>this.markFileDirty(e),setDbgCurrentLine:e=>{this.dbgCurrentLine=e}},this.preLoadedPackages.forEach((e=>{this.notifyStatus("pre-loading "+e),this.pyodide.loadPackage(e).then((()=>{this.loadedModuleNames.push(e),this.notifyStatus(e+" pre-loaded")})).catch((n=>{this.failedModuleNames.push(e),this.notifyStatus("error pre-loading "+e+n)}))})),this.pyodide.runPython('\n                import sys\n                import io\n                from js import pyodideGlobal\n\n                class __ImportIntercept:\n                    def find_spec(self, name, path, module):\n                        pyodideGlobal.requestModule(name)\n                sys.meta_path.append(__ImportIntercept())\n\n                class MyTextFile(io.StringIO):\n                    def __init__(self, filename, mode="r"):\n                        self.filename = filename\n                        self.readOnly = mode == "r"\n                        content = pyodideGlobal.fs.getFile(filename)\n                        if content is None:\n                            if self.readOnly:\n                                raise FileNotFoundError(filename)\n                            content = ""\n                        else:\n                            if mode == "w":\n                                content = ""\n                            elif mode == "x":\n                                raise FileExistsError(filename)\n                        super().__init__(content if content is not None else "")\n                        if mode == "a":\n                            self.seek(0, 2)\n                    def close(self):\n                        if not self.readOnly:\n                            content = self.getvalue()\n                            pyodideGlobal.fs.setFile(self.filename, content)\n                            pyodideGlobal.markFileDirty(self.filename)\n                            super().close()\n\n                def open(filename, mode="r", encoding=None):\n                    return MyTextFile(filename, mode)\n\n                import os\n\n                def __os_listdir(path="."):\n                    return list(pyodideGlobal.fs.getDir())\n                os.listdir = __os_listdir\n\n                # user code execution\n                global_variables = {\n                    "open": open,\n                    "input": input\n                }\n\n                # global debugger\n                dbg = None\n\n                def execute_code(src, breakpoints=None):\n                    """Return 0 if done, 1 if suspended in debugger, 2 if waiting for input"""\n\n                    class Dbg:\n\n                        import sys\n                        import os\n                        import re\n\n                        class Suspended(Exception):\n                            pass\n\n                        class SuspendedForInput(Suspended):\n                            pass\n\n                        def __init__(self, interactive=True):\n                            self.interactive = interactive\n                            self.frame = None\n\n                            # breakpoint line numbers\n                            self.breakpoints = set()\n                            self.break_at_start = True\n                            # past actions or inputs from the user\n                            # ("c"=continue, "n"=next, "s"=step, "r"=return, etc.)\n                            # resume will execute them and suspend execution when they are exhausted\n                            self.debug_action_history = []\n                            # True to ignore trace calls until 2nd event="call"\n                            self.ignore_top_call = False\n                            # substitution for input global function\n                            self.input_debug = None\n\n                            self.last_command = ""\n\n                            self.init_output()\n                            self.null = open(self.os.devnull, "w")\n\n                        def init_output(self):\n                            self.stdout = self.sys.stdout\n                            self.stderr = self.sys.stderr\n\n                        def enable_print(self, on):\n                            self.sys.stdout = self.stdout if on else self.null\n                            self.sys.stderr = self.stderr if on else self.null\n\n                        def clear_breakspoints(self):\n                            self.breakpoints = set()\n\n                        def set_breakpoint(self, lineno):\n                            self.breakpoints.add(lineno)\n\n                        def clear_breakspoint(self, lineno):\n                            self.breakpoints.remove(lineno)\n\n                        def is_suspended(self):\n                            return self.frame is not None\n\n                        def is_requesting_input(self):\n                            return self.request_input\n\n                        def debug_(self, fun, ignore_top_call, args, kwargs):\n                            self.fun = fun\n                            self.args = args\n                            self.kwargs = kwargs\n                            self.ignore_top_call = ignore_top_call\n                            self.returned_value = None\n                            self.debug_action_history = []\n                            self.resume(None)\n                            if self.interactive:\n                                self.cli()\n\n                        def debug_call(self, fun, *args, **kwargs):\n                            self.debug_(fun, False, args, kwargs)\n\n                        def debug_code(self, code, globals=globals(), locals=None):\n                            def input(prompt):\n                                return self.input_debug(prompt)\n                            globals["input"] = input\n                            self.debug_(lambda: exec(code, globals, locals), True, (), {})\n\n                        def resume(self, cmd):\n                            if cmd is not None:\n                                self.debug_action_history.append(cmd)\n\n                            # state ("s"=step, "n"=next, "r"=return, "c"=continue)\n                            state = "s" if self.break_at_start else "c"\n                            # index of first action in self.debug_action_history to perform\n                            action_count = 0\n                            # call depth used for "n" and "r"\n                            call_depth = 0\n                            last_break_depth = 0\n                            # number of event "call"\n                            call_count = 0\n\n                            def trace(frame, event, arg):\n                                nonlocal state, action_count, call_depth, last_break_depth, call_count\n                                if self.ignore_top_call:\n                                    if event == "call":\n                                        if frame.f_code.co_name == "input":\n                                            if action_count >= len(self.debug_action_history):\n                                                # call to input(prompt): display prompt and request user input\n                                                if frame.f_locals["prompt"] is not None:\n                                                    self.sys.stdout.write(frame.f_locals["prompt"])\n                                                self.frame = frame\n                                                raise self.SuspendedForInput()\n                                            else:\n                                                # execute input() defined below (picks input in self.debug_action_history)\n                                                pass\n                                        call_count += 1\n                                        call_depth += 1\n                                    if call_count < 2:\n                                        return\n                                if event == "line":\n                                    self.current_line = frame.f_lineno\n                                    if (state == "n" and call_depth <= last_break_depth or\n                                        state == "r" and call_depth < last_break_depth or\n                                        state == "s" or\n                                        frame.f_lineno in self.breakpoints):\n                                        # breakpoint (explicit, or following s/n/r which should break here)\n                                        if action_count >= len(self.debug_action_history):\n                                            # not reached yet: really break here\n                                            self.frame = frame\n                                            raise self.Suspended()\n                                        else:\n                                            # already reached: continue\n                                            state = self.debug_action_history[action_count]\n                                            action_count += 1\n                                            last_break_depth = call_depth\n                                            if action_count >= len(self.debug_action_history):\n                                                self.enable_print(True)\n                                    elif action_count >= len(self.debug_action_history):\n                                        self.enable_print(True)\n                                elif event == "call":\n                                    call_depth += 1\n                                elif event == "return":\n                                    call_depth -= 1\n                                return trace\n\n                            def input(prompt):\n                                nonlocal action_count\n                                str = self.debug_action_history[action_count]\n                                action_count += 1\n                                return str\n                            self.input_debug = input\n\n                            suspended = False\n                            self.request_input = False\n                            self.enable_print(len(self.debug_action_history) <= 1)\n                            self.sys.settrace(trace)\n                            try:\n                                self.returned_value = self.fun(*self.args, **self.kwargs)\n                            except self.SuspendedForInput:\n                                suspended = True\n                                self.request_input = True\n                            except self.Suspended:\n                                suspended = True\n                            finally:\n                                self.sys.settrace(None)\n                                self.enable_print(True)\n                            if not suspended:\n                                self.frame = None\n\n                        def eval_code(self, src):\n                            try:\n                                code = compile(src, "<stdin>", "single")\n                                exec(code,\n                                     self.frame.f_globals,\n                                     self.frame.f_locals)\n                            except Exception as e:\n                                import traceback\n                                traceback.print_exception(etype=type(e),\n                                                          value=e,\n                                                          tb=e.__traceback__)\n\n                        def exec_cmd(self, cmd):\n                            cmd = cmd.strip() or self.last_command\n                            r = self.re.compile(r"^(S+)(s+(S+))$")\n                            match = r.match(cmd)\n                            if match:\n                                cmd0 = match.groups()[0]\n                                arg = match.groups()[2]\n                            else:\n                                cmd0 = cmd\n                                arg = None\n                            if cmd0 in ["b", "break"]:\n                                if arg is None:\n                                    print(self.breakpoints)\n                                else:\n                                    try:\n                                        lineno = int(arg)\n                                        self.set_breakpoint(lineno)\n                                    except:\n                                        print("Bad line number")\n                                self.last_command = ""\n                            elif cmd in ["c", "continue"]:\n                                self.resume("c")\n                                self.last_command = cmd\n                            elif cmd0 in ["cl", "clear"]:\n                                if arg:\n                                    try:\n                                        lineno = int(arg)\n                                        self.clear_breakspoint(lineno)\n                                    except:\n                                        print("Bad line number")\n                                else:\n                                    self.clear_breakspoints()\n                                self.last_command = ""\n                            elif cmd in ["h", "help"]:\n                                import textwrap\n                                print(textwrap.dedent("""\n                                    b(reak) line  break at specified line\n                                    c(ontinue)    continue\n                                    cl(ear)       clear all breakpoints\n                                    h(elp)        help\n                                    q(quit)       quit\n                                    r(eturn)      continue until the current function returns\n                                    s(tep)        step\n                                    w(here)       display a stack trace\n                                    expr          evaluate expression, including local and global variables\n                                    """))\n                                self.last_command = ""\n                            elif cmd in ["q", "quit"]:\n                                self.frame = None\n                            elif cmd in ["n", "next"]:\n                                self.resume("n")\n                                self.last_command = cmd\n                            elif cmd in ["r", "return"]:\n                                self.resume("r")\n                                self.last_command = cmd\n                            elif cmd in ["s", "step"]:\n                                self.resume("s")\n                                self.last_command = cmd\n                            elif cmd in ["w", "where"]:\n                                frame = self.frame\n                                while frame and (frame.f_code.co_name != "resume"):\n                                    print(f"{frame.f_code.co_name} at line {frame.f_lineno}")\n                                    frame = frame.f_back\n                            elif cmd != "":\n                                self.eval_code(cmd)\n\n                            # return true when execution is completed\n                            return self.frame is None\n\n                        def submit_input(self, input):\n                            self.debug_action_history.append(input)\n                            self.resume(None)\n\n                        def cli(self):\n                            while self.is_suspended():\n                                cmd = input(f"{self.frame.f_code.co_name}:{self.frame.f_lineno} dbg> ")\n                                self.exec_cmd(cmd)\n\n                    try:\n                        code = compile(src, "<stdin>", mode="single")\n                    except SyntaxError:\n                        code = compile(src, "<stdin>", mode="exec")\n\n                    if breakpoints:\n                        global dbg\n                        dbg = Dbg(False)\n                        dbg.break_at_start = False;\n                        for breakpoint in breakpoints:\n                            dbg.set_breakpoint(breakpoint)\n                        dbg.debug_code(code, globals=global_variables)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n                    else:\n                        exec(code, global_variables)\n                        return 0\n\n                def continue_debugging(dbg_command):\n                    if dbg is not None and dbg.is_suspended():\n                        dbg.init_output()  # can be a new io.StringIO() object\n                        dbg.exec_cmd(dbg_command)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n\n                def submit_input_to_debugger(input):\n                    if dbg is not None and dbg.is_suspended() and dbg.request_input:\n                        dbg.init_output()  # can be a new io.StringIO() object\n                        dbg.submit_input(input)\n                        return 0 if not dbg.is_suspended() else 2 if dbg.request_input else 1\n\n                def debug_current_line():\n                    return dbg.current_line if dbg and dbg.is_suspended() else None\n            '),e&&e()}))}requestModule(e){this.requestedModuleNames.indexOf(e)<0&&this.loadedModuleNames.indexOf(e)<0&&this.failedModuleNames.indexOf(e)<0&&this.requestedModuleNames.push(e)}markFileDirty(e){this.dirtyFiles.indexOf(e)<0&&(this.dirtyFiles.push(e),this.notifyDirtyFile(e))}getDirtyFilePaths(e){let n=this.dirtyFiles;return e&&(this.dirtyFiles=[]),n}run(e,n){if(""===e.trim())return!0;this.pyodide.runPython("\n            import io, sys\n            sys.stdout = io.StringIO()\n            sys.stderr = sys.stdout\n        "),this.loadedModuleNames.indexOf("matplotlib")>=0&&this.pyodide.runPython('\n                import matplotlib\n                matplotlib.use("Agg")\n            '),this.handleInput&&this.pyodide.runPython('\n                class CodeWithInputEvaluator:\n\n                    def __init__(self, src, global_variables):\n\n                        import ast\n\n                        def check_node(node, block_reason=None):\n                            """Check that input function is called only from where it is supported,\n                            i.e. at top-level if block_reason is None, not in functions or methods, and\n                            nowhere if block_reason is a string describing the offending context. Raise\n                            an exception otherwise.\n                            """\n                            if type(node) is ast.ClassDef:\n                                block_reason = "class"\n                            elif type(node) is ast.FunctionDef:\n                                block_reason = "def"\n                            elif type(node) is ast.Lambda:\n                                block_reason = "lambda"\n                            elif block_reason and type(node) is ast.Call and type(node.func) is ast.Name and node.func.id == "input":\n                                raise Exception(f"input call not supported in {block_reason} at line {node.lineno}")\n                            for child in ast.iter_child_nodes(node):\n                                check_node(child, block_reason)\n\n                        def check(src):\n                            """Check that input function is called only from where it is supported,\n                            i.e. at top-level, not in functions or methods. Raise an exception otherwise.\n                            """\n                            root = ast.parse(src)\n                            check_node(root)\n\n                        def replace_input_with_yield(src, function_name, global_var_names=[]):\n\n                            """Compile source code and replace input calls with yield.\n                            """\n                            class Replacer(ast.NodeTransformer):\n                                """NodeTransformer which replaces input(prompt) with\n                                yield((False,prompt,locals()))\n                                """\n                                def visit_Call(self, node):\n                                    self.generic_visit(node)\n                                    if type(node.func) is ast.Name and node.func.id == "input":\n                                        input_arg = node.args[0] if len(node.args) > 0 else ast.NameConstant(value=None)\n                                        y = ast.Yield(value=ast.Tuple(\n                                            elts=[\n                                                ast.NameConstant(value=False),\n                                                input_arg,\n                                                ast.Call(func=ast.Name(id="locals", ctx=ast.Load()), args=[], keywords=[])\n                                            ],\n                                            ctx=ast.Load()\n                                        ))\n                                        return y\n                                    return node\n\n                            # compile to ast\n                            root = ast.parse(src)\n\n                            # check that input is called only from top-level code, not functions\n                            check_node(root)\n\n                            # replace input(prompt) with yield (False,prompt,locals())\n                            replacer = Replacer()\n                            root1 = replacer.visit(root)\n\n                            # replace last statement with "import sys; sys.displayhook(expr)" if it is an expr\n                            last_el = root1.body[-1]\n                            if type(last_el) is ast.Expr:\n                                expr = root1.body.pop()\n                                root1.body.append(ast.Import(\n                                    names=[\n                                        ast.alias(name="sys", asname=None)\n                                    ]\n                                ))\n                                root1.body.append(ast.Expr(\n                                    value=ast.Call(\n                                        func=ast.Attribute(attr="displayhook", value=ast.Name(id="sys", ctx=ast.Load()), ctx=ast.Load()),\n                                        args=[expr.value],\n                                        keywords=[]\n                                    )\n                                ))\n\n                            # append yield (True,None,locals())\n                            y = ast.Expr(\n                                value=ast.Yield(value=ast.Tuple(\n                                    elts=[\n                                        ast.NameConstant(value=True),\n                                        ast.NameConstant(value=None),\n                                        ast.Call(func=ast.Name(id="locals", ctx=ast.Load()), args=[], keywords=[])\n                                    ],\n                                    ctx=ast.Load()\n                                ))\n                            )\n                            root1.body.append(y)\n\n                            # define a coroutine\n                            root1.body = [\n                                ast.FunctionDef(\n                                    name=function_name,\n                                    args=ast.arguments(\n                                        posonlyargs=[],\n                                        args=[ast.arg(arg=g, annotation=None) for g in global_var_names],\n                                        defaults=[],\n                                        kwarg=None,\n                                        kw_defaults=[],\n                                        kwonlyargs=[],\n                                        vararg=None\n                                    ),\n                                    body=root1.body,\n                                    decorator_list=[],\n                                    returns=None\n                                )\n                            ]\n\n                            # add dummy missing lineno and col_offset to make compiler happy\n                            for node in ast.walk(root1):\n                                if not hasattr(node, "lineno"):\n                                    node.lineno = 1\n                                if not hasattr(node, "col_offset"):\n                                    node.col_offset = 999\n\n                            # compile\n                            code = compile(root1, "<ast>", "exec")\n\n                            return code\n\n                        def run_code_with_input_as_coroutine(src, global_variables):\n                            code = replace_input_with_yield(src, "corout", global_variables)\n                            gl = {}\n                            exec(code, gl)\n                            co = gl["corout"](**global_variables)\n                            return co\n\n                        self.global_variables = global_variables\n                        self.co = run_code_with_input_as_coroutine(src, global_variables)\n                        self.done, self.prompt, new_global_variables = self.co.send(None)\n                        self.global_variables.update(new_global_variables)\n\n                    def submit_input(self, input):\n                        self.done, self.prompt, new_global_variables = self.co.send(input)\n                        self.global_variables.update(new_global_variables)\n\n                    def cancel_input(self):\n                        self.co.close()\n            ');let t="";this.requestedModuleNames=[],this.suspended=!1,this.dbgCurrentLine=null;try{if(this.notifyStatus("running"),self.pyodideGlobal.setFigureURL=e=>this.setFigureURL(e),this.pyodide.globals.set("src",e),n&&n.length>0){const e="["+n.map((e=>e.toString(10))).join(", ")+"]";this.pyodide.runPython(`\n                    import js\n                    status = execute_code(src, breakpoints=${e})\n                    suspended = status != 0\n                    done = not suspended\n                    js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n                `),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2===this.pyodide.globals.get("status"),this.inputPrompt=null}else this.handleInput?(this.pyodide.runPython("evaluator = CodeWithInputEvaluator(src, global_variables)"),this.requestInput=!1,this.pyodide.runPython("\n                    done = evaluator.done\n                    suspended = False\n                    # suspended = evaluator.suspended\n                    input_prompt = evaluator.prompt\n                "),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||(this.inputPrompt=this.pyodide.globals.get("input_prompt"),this.requestInput=!0)):this.pyodide.runPython("execute_code(src); done = True; suspended = False");this.loadedModuleNames.indexOf("matplotlib")>=0&&this.pyodide.runPython('\n                    import matplotlib.pyplot, io, base64, js\n                    if matplotlib.pyplot.get_fignums():\n                        with io.BytesIO() as buf:\n                            matplotlib.pyplot.savefig(buf, format="png")\n                            buf.seek(0)\n                            js.pyodideGlobal.setFigureURL("data:image/png;base64," +\n                                base64.b64encode(buf.read()).decode("ascii"))\n                ')}catch(n){if(/ModuleNotFoundError/.test(n.message)&&this.requestedModuleNames.length>0){const n=this.requestedModuleNames.shift();return this.notifyStatus("loading module "+n),this.pyodide.loadPackage(n).then((()=>{this.loadedModuleNames.push(n),this.notifyStatus("running"),this.run(e)})).catch((()=>{this.failedModuleNames.push(n),this.postExec&&this.postExec()})),!1}t=n.message,this.pyodide.globals.set("done",!0)}let s=this.pyodide.runPython("sys.stdout.getvalue()");return this.write(s+t),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(null==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec(),!0}submitInput(e){if(this.requestInput){this.pyodide.runPython("\n                import io, sys\n                sys.stdout = io.StringIO()\n                sys.stderr = sys.stdout\n            "),this.inlineInput||this.write((null==this.inputPrompt?"? ":this.inputPrompt)+e+"\n"),this.requestInput=!1,self.input_string=e;let n="";if(this.suspended)try{this.pyodide.runPython("\n                        import js\n                        status = submit_input_to_debugger(js.input_string)\n                        suspended = status != 0\n                        done = not suspended\n                        js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n                    "),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2==this.pyodide.globals.get("status"),this.inputPrompt=null}catch(e){}else try{this.pyodide.runPython("\n                        import js\n                        evaluator.submit_input(js.input_string)\n                        done = evaluator.done\n                        # suspended = evaluator.suspended\n                        input_prompt = evaluator.prompt\n                    "),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||(this.inputPrompt=this.pyodide.globals.get("input_prompt"),this.requestInput=!0)}catch(e){n=e.message,this.pyodide.globals.set("done",!0)}let t=this.pyodide.runPython("sys.stdout.getvalue()");this.write(t+n),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(null==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec()}}cancelInput(){if(this.requestInput){this.requestInput=!1;try{this.pyodide.runPython("evaluator.cancel_input()")}catch(e){}this.dbgCurrentLine=null}}continueDebugging(e){this.pyodide.runPython("import io, syssys.stdout = io.StringIO()sys.stderr = sys.stdout");try{self.dbg_command=e,this.pyodide.runPython("\n                import js\n                status = continue_debugging(js.dbg_command)\n                suspended = status != 0\n                done = not suspended\n                js.pyodideGlobal.setDbgCurrentLine(debug_current_line())\n            "),this.suspended=this.pyodide.globals.get("suspended"),this.requestInput=2==this.pyodide.globals.get("status"),this.inputPrompt=null}catch(e){}let n=this.pyodide.runPython("sys.stdout.getvalue()");this.write(n),this.pyodide.globals.get("done")||this.pyodide.globals.get("suspended")||!this.inlineInput||this.write(null==this.inputPrompt?"? ":this.inputPrompt),this.postExec&&this.postExec()}clearFigure(){if(this.loadedModuleNames.indexOf("matplotlib")>=0){this.pyodide.runPython("\n                import matplotlib.pyplot\n                matplotlib.pyplot.close()\n            ");const e="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";this.setFigureURL(e)}}clear(){this.clearText(),this.clearFigure()}}importScripts(`${e}pyodide.js`);var o=!1;let l=!1,a="",r=-1;var d=null;function u(e,n){postMessage({cmd:"status",status:n&&n.length>0?"debugging":"running"}),d.run(e,n)}onmessage=n=>{function t(n){const t={write:e=>{a+=e},clearText:()=>{a="",l=!0},setFigureURL:e=>{postMessage({cmd:"figure",data:e})},notifyStatus:e=>{postMessage({cmd:"status",status:e})},notifyDirtyFile:e=>{postMessage({cmd:"dirty",data:e})},postExec:function(){!function(e){let n=Date.now();e&&(r=n),r<0?r=n+10:r<=n&&(l&&(postMessage({cmd:"clear"}),l=!1),a&&(postMessage({cmd:"print",data:a}),a=""),r=-1)}(!0),postMessage({cmd:"done",suspendedAt:d.suspended?d.dbgCurrentLine:null}),d.requestInput&&postMessage({cmd:"input",prompt:d.inputPrompt})},handleInput:n&&n.handleInput||!1,inlineInput:n&&n.inlineInput||!1,preLoadedPackages:n?.preLoadedPackages||[],pyodideURL:e};console.log("options inside worker: ",t),d=new i(t)}let s=JSON.parse(n.data);if("config"===s.cmd)t(s.options);else switch(null==d&&t(),s.cmd){case"preload":postMessage({cmd:"status",status:"startup"}),d.load((()=>{o=!0,postMessage({cmd:"done"})}));break;case"run":o?u(s.code,s.breakpoints):(postMessage({cmd:"status",status:"startup"}),d.load((()=>{u(s.code,s.breakpoints),o=!0})));break;case"submit":p=s.str,d.submitInput(p,c);break;case"cancel":d.cancelInput();break;case"debug":if(o&&d.suspended)switch(s.dbg){case"next":case"step":case"return":case"continue":case"quit":d.continueDebugging(s.dbg)}else postMessage({cmd:"done"});break;case"get":postMessage({cmd:"file",path:s.path,data:d.fs.getFile(s.path)});break;case"put":d.fs.setFile(s.path,s.data);break;case"clearFigure":d.clearFigure()}var p,c};
